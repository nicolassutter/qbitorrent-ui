// This file is auto-generated by @hey-api/openapi-ts

/**
 * The response is a JSON object containing the following fields
 */
export type BuildInfo = {
    qt?: string;
    libtorrent?: string;
    boost?: string;
    openssl?: string;
    bitness?: number;
};

/**
 * Possible fields:
 */
export type Preferences = {
    /**
     * Currently selected language (e.g. en_GB for English)
     */
    locale?: string;
    /**
     * True if a subfolder should be created when adding a torrent
     */
    create_subfolder_enabled?: boolean;
    /**
     * True if torrents should be added in a Paused state
     */
    start_paused_enabled?: boolean;
    /**
     * TODO
     */
    auto_delete_mode?: number;
    /**
     * True if disk space should be pre-allocated for all files
     */
    preallocate_all?: boolean;
    /**
     * True if ".!qB" should be appended to incomplete files
     */
    incomplete_files_ext?: boolean;
    /**
     * True if Automatic Torrent Management is enabled by default
     */
    auto_tmm_enabled?: boolean;
    /**
     * True if torrent should be relocated when its Category changes
     */
    torrent_changed_tmm_enabled?: boolean;
    /**
     * True if torrent should be relocated when the default save path changes
     */
    save_path_changed_tmm_enabled?: boolean;
    /**
     * True if torrent should be relocated when its Category's save path changes
     */
    category_changed_tmm_enabled?: boolean;
    /**
     * Default save path for torrents, separated by slashes
     */
    save_path?: string;
    /**
     * True if folder for incomplete torrents is enabled
     */
    temp_path_enabled?: boolean;
    /**
     * Path for incomplete torrents, separated by slashes
     */
    temp_path?: string;
    /**
     * Property: directory to watch for torrent files, value: where torrents loaded from this directory should be downloaded to (see list of possible values below). Slashes are used as path separators; multiple key/value pairs can be specified
     *
     * | Value                  | Description                       |
     * | ---------------------- | --------------------------------- |
     * | 0                      | Download to the monitored folder  |
     * | 1                      | Download to the default save path |
     * | "/path/to/download/to" | Download to this path             |
     *
     */
    scan_dirs?: {
        [key: string]: 0 | 1 | string;
    };
    /**
     * Path to directory to copy .torrent files to. Slashes are used as path separators
     */
    export_dir?: string;
    /**
     * Path to directory to copy .torrent files of completed downloads to. Slashes are used as path separators
     */
    export_dir_fin?: string;
    /**
     * True if e-mail notification should be enabled
     */
    mail_notification_enabled?: boolean;
    /**
     * e-mail where notifications should originate from
     */
    mail_notification_sender?: string;
    /**
     * e-mail to send notifications to
     */
    mail_notification_email?: string;
    /**
     * smtp server for e-mail notifications
     */
    mail_notification_smtp?: string;
    /**
     * True if smtp server requires SSL connection
     */
    mail_notification_ssl_enabled?: boolean;
    /**
     * True if smtp server requires authentication
     */
    mail_notification_auth_enabled?: boolean;
    /**
     * Username for smtp authentication
     */
    mail_notification_username?: string;
    /**
     * Password for smtp authentication
     */
    mail_notification_password?: string;
    /**
     * True if external program should be run after torrent has finished downloading
     */
    autorun_enabled?: boolean;
    /**
     * Program path/name/arguments to run if `autorun_enabled` is enabled; path is separated by slashes; you can use `%f` and `%n` arguments, which will be expanded by qBittorent as path_to_torrent_file and torrent_name (from the GUI; not the .torrent file name) respectively
     */
    autorun_program?: string;
    /**
     * True if torrent queuing is enabled
     */
    queueing_enabled?: boolean;
    /**
     * Maximum number of active simultaneous downloads
     */
    max_active_downloads?: number;
    /**
     * Maximum number of active simultaneous downloads and uploads
     */
    max_active_torrents?: number;
    /**
     * Maximum number of active simultaneous uploads
     */
    max_active_uploads?: number;
    /**
     * If true torrents w/o any activity (stalled ones) will not be counted towards `max_active_*` limits; see [dont_count_slow_torrents](https://www.libtorrent.org/reference-Settings.html#dont_count_slow_torrents) for more information
     */
    dont_count_slow_torrents?: boolean;
    /**
     * Download rate in KiB/s for a torrent to be considered "slow"
     */
    slow_torrent_dl_rate_threshold?: number;
    /**
     * Upload rate in KiB/s for a torrent to be considered "slow"
     */
    slow_torrent_ul_rate_threshold?: number;
    /**
     * Seconds a torrent should be inactive before considered "slow"
     */
    slow_torrent_inactive_timer?: number;
    /**
     * True if share ratio limit is enabled
     */
    max_ratio_enabled?: boolean;
    /**
     * Get the global share ratio limit
     */
    max_ratio?: number;
    /**
     * Action performed when a torrent reaches the maximum share ratio. See list of possible values here below.
     *
     * | Value | Description    |
     * | ----- | -------------- |
     * | 0     | Pause torrent  |
     * | 1     | Remove torrent |
     *
     */
    max_ratio_act?: 0 | 1;
    /**
     * Port for incoming connections
     */
    listen_port?: number;
    /**
     * True if UPnP/NAT-PMP is enabled
     */
    upnp?: boolean;
    /**
     * True if the port is randomly selected
     */
    random_port?: boolean;
    /**
     * Global download speed limit in KiB/s; `-1` means no limit is applied
     */
    dl_limit?: number;
    /**
     * Global upload speed limit in KiB/s; `-1` means no limit is applied
     */
    up_limit?: number;
    /**
     * Maximum global number of simultaneous connections
     */
    max_connec?: number;
    /**
     * Maximum number of simultaneous connections per torrent
     */
    max_connec_per_torrent?: number;
    /**
     * Maximum number of upload slots
     */
    max_uploads?: number;
    /**
     * Maximum number of upload slots per torrent
     */
    max_uploads_per_torrent?: number;
    /**
     * Timeout in seconds for a `stopped` announce request to trackers
     */
    stop_tracker_timeout?: number;
    /**
     * True if the advanced libtorrent option `piece_extent_affinity` is enabled
     */
    enable_piece_extent_affinity?: boolean;
    /**
     * Bittorrent Protocol to use (see list of possible values below)
     *
     * | Value | Description |
     * | ----- | ----------- |
     * | 0     | TCP and μTP |
     * | 1     | TCP         |
     * | 2     | μTP         |
     *
     */
    bittorrent_protocol?: 0 | 1 | 2;
    /**
     * True if `[du]l_limit` should be applied to uTP connections; this option is only available in qBittorent built against libtorrent version 0.16.X and higher
     */
    limit_utp_rate?: boolean;
    /**
     * True if `[du]l_limit` should be applied to estimated TCP overhead (service data: e.g. packet headers)
     */
    limit_tcp_overhead?: boolean;
    /**
     * True if `[du]l_limit` should be applied to peers on the LAN
     */
    limit_lan_peers?: boolean;
    /**
     * Alternative global download speed limit in KiB/s
     */
    alt_dl_limit?: number;
    /**
     * Alternative global upload speed limit in KiB/s
     */
    alt_up_limit?: number;
    /**
     * True if alternative limits should be applied according to schedule
     */
    scheduler_enabled?: boolean;
    /**
     * Scheduler starting hour
     */
    schedule_from_hour?: number;
    /**
     * Scheduler starting minute
     */
    schedule_from_min?: number;
    /**
     * Scheduler ending hour
     */
    schedule_to_hour?: number;
    /**
     * Scheduler ending minute
     */
    schedule_to_min?: number;
    /**
     * Scheduler days. See possible values here below
     *
     * | Value | Description     |
     * | ----- | --------------- |
     * | 0     | Every day       |
     * | 1     | Every weekday   |
     * | 2     | Every weekend   |
     * | 3     | Every Monday    |
     * | 4     | Every Tuesday   |
     * | 5     | Every Wednesday |
     * | 6     | Every Thursday  |
     * | 7     | Every Friday    |
     * | 8     | Every Saturday  |
     * | 9     | Every Sunday    |
     *
     */
    scheduler_days?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9;
    /**
     * True if DHT is enabled
     */
    dht?: boolean;
    /**
     * True if PeX is enabled
     */
    pex?: boolean;
    /**
     * True if LSD is enabled
     */
    lsd?: boolean;
    /**
     * See list of possible values here below
     *
     * | Value | Description          |
     * | ----- | -------------------- |
     * | 0     | Prefer encryption    |
     * | 1     | Force encryption on  |
     * | 2     | Force encryption off |
     *
     */
    encryption?: 0 | 1 | 2;
    /**
     * If true anonymous mode will be enabled; read more [here](https://github.com/qbittorrent/qBittorrent/wiki/Anonymous-Mode); this option is only available in qBittorent built against libtorrent version 0.16.X and higher
     */
    anonymous_mode?: boolean;
    /**
     * See list of possible values here below
     *
     * | Value | Description                         |
     * | ----- | ----------------------------------- |
     * | -1    | Proxy is disabled                   |
     * | 0     | Prefer encryption                   |
     * | 1     | HTTP proxy without authentication   |
     * | 2     | SOCKS5 proxy without authentication |
     * | 3     | HTTP proxy with authentication      |
     * | 4     | SOCKS5 proxy with authentication    |
     * | 5     | SOCKS4 proxy without authentication |
     *
     */
    proxy_type?: -1 | 0 | 1 | 2 | 3 | 4 | 5;
    /**
     * Proxy IP address or domain name
     */
    proxy_ip?: string;
    /**
     * Proxy port
     */
    proxy_port?: number;
    /**
     * True if peer and web seed connections should be proxified; this option will have any effect only in qBittorent built against libtorrent version 0.16.X and higher
     */
    proxy_peer_connections?: boolean;
    /**
     * True proxy requires authentication; doesn't apply to SOCKS4 proxies
     */
    proxy_auth_enabled?: boolean;
    /**
     * Username for proxy authentication
     */
    proxy_username?: string;
    /**
     * Password for proxy authentication
     */
    proxy_password?: string;
    /**
     * True if proxy is only used for torrents
     */
    proxy_torrents_only?: boolean;
    /**
     * True if external IP filter should be enabled
     */
    ip_filter_enabled?: boolean;
    /**
     * Path to IP filter file (.dat, .p2p, .p2b files are supported); path is separated by slashes
     */
    ip_filter_path?: string;
    /**
     * True if IP filters are applied to trackers
     */
    ip_filter_trackers?: boolean;
    /**
     * Comma-separated list of domains to accept when performing Host header validation
     */
    web_ui_domain_list?: Array<string>;
    /**
     * IP address to use for the WebUI
     */
    web_ui_address?: string;
    /**
     * WebUI port
     */
    web_ui_port?: number;
    /**
     * True if UPnP is used for the WebUI port
     */
    web_ui_upnp?: boolean;
    /**
     * WebUI username
     */
    web_ui_username?: string;
    /**
     * True if WebUI CSRF protection is enabled
     */
    web_ui_csrf_protection_enabled?: boolean;
    /**
     * True if WebUI clickjacking protection is enabled
     */
    web_ui_clickjacking_protection_enabled?: boolean;
    /**
     * True if WebUI cookie `Secure` flag is enabled
     */
    web_ui_secure_cookie_enabled?: boolean;
    /**
     * Maximum number of authentication failures before WebUI access ban
     */
    web_ui_max_auth_fail_count?: number;
    /**
     * WebUI access ban duration in seconds
     */
    web_ui_ban_duration?: number;
    /**
     * Seconds until WebUI is automatically signed off
     */
    web_ui_session_timeout?: number;
    /**
     * True if WebUI host header validation is enabled
     */
    web_ui_host_header_validation_enabled?: boolean;
    /**
     * True if authentication challenge for loopback address (127.0.0.1) should be disabled
     */
    bypass_local_auth?: boolean;
    /**
     * True if webui authentication should be bypassed for clients whose ip resides within (at least) one of the subnets on the whitelist
     */
    bypass_auth_subnet_whitelist_enabled?: boolean;
    /**
     * (White)list of ipv4/ipv6 subnets for which webui authentication should be bypassed; list entries are separated by commas
     */
    bypass_auth_subnet_whitelist?: Array<string>;
    /**
     * True if an alternative WebUI should be used
     */
    alternative_webui_enabled?: boolean;
    /**
     * File path to the alternative WebUI
     */
    alternative_webui_path?: string;
    /**
     * True if WebUI HTTPS access is enabled
     */
    use_https?: boolean;
    /**
     * For API < v2.0.1: SSL keyfile contents (this is a not a path)
     */
    ssl_key?: string;
    /**
     * For API < v2.0.1: SSL certificate contents (this is a not a path)
     */
    ssl_cert?: string;
    /**
     * For API ≥ v2.0.1: Path to SSL keyfile
     */
    web_ui_https_key_path?: string;
    /**
     * For API ≥ v2.0.1: Path to SSL certificate
     */
    web_ui_https_cert_path?: string;
    /**
     * True if server DNS should be updated dynamically
     */
    dyndns_enabled?: boolean;
    /**
     * See list of possible values here below
     *
     * | Value | Description |
     * | ----- | ----------- |
     * | 0     | Use DyDNS   |
     * | 1     | Use NOIP    |
     *
     */
    dyndns_service?: 0 | 1;
    /**
     * Username for DDNS service
     */
    dyndns_username?: string;
    /**
     * Password for DDNS service
     */
    dyndns_password?: string;
    /**
     * Your DDNS domain name
     */
    dyndns_domain?: string;
    /**
     * RSS refresh interval
     */
    rss_refresh_interval?: number;
    /**
     * Max stored articles per RSS feed
     */
    rss_max_articles_per_feed?: number;
    /**
     * Enable processing of RSS feeds
     */
    rss_processing_enabled?: boolean;
    /**
     * Enable auto-downloading of torrents from the RSS feeds
     */
    rss_auto_downloading_enabled?: boolean;
    /**
     * For API ≥ v2.5.1: Enable downloading of repack/proper Episodes
     */
    rss_download_repack_proper_episodes?: boolean;
    /**
     * For API ≥ v2.5.1: List of RSS Smart Episode Filters
     */
    rss_smart_episode_filters?: string;
    /**
     * Enable automatic adding of trackers to new torrents
     */
    add_trackers_enabled?: boolean;
    /**
     * List of trackers to add to new torrent
     */
    add_trackers?: string;
    /**
     * For API ≥ v2.5.1: Enable custom http headers
     */
    web_ui_use_custom_http_headers_enabled?: boolean;
    /**
     * For API ≥ v2.5.1: List of custom http headers
     */
    web_ui_custom_http_headers?: string;
    /**
     * True enables max seeding time
     */
    max_seeding_time_enabled?: boolean;
    /**
     * Number of minutes to seed a torrent
     */
    max_seeding_time?: number;
    /**
     * TODO
     */
    announce_ip?: string;
    /**
     * True always announce to all tiers
     */
    announce_to_all_tiers?: boolean;
    /**
     * True always announce to all trackers in a tier
     */
    announce_to_all_trackers?: boolean;
    /**
     * Number of asynchronous I/O threads
     */
    async_io_threads?: number;
    /**
     * List of banned IPs
     */
    banned_IPs?: string;
    /**
     * Outstanding memory when checking torrents in MiB
     */
    checking_memory_use?: number;
    /**
     * IP Address to bind to. Empty String means All addresses
     */
    current_interface_address?: string;
    /**
     * Network Interface used
     */
    current_network_interface?: string;
    /**
     * Disk cache used in MiB
     */
    disk_cache?: number;
    /**
     * Disk cache expiry interval in seconds
     */
    disk_cache_ttl?: number;
    /**
     * Port used for embedded tracker
     */
    embedded_tracker_port?: number;
    /**
     * True enables coalesce reads & writes
     */
    enable_coalesce_read_write?: boolean;
    /**
     * True enables embedded tracker
     */
    enable_embedded_tracker?: boolean;
    /**
     * True allows multiple connections from the same IP address
     */
    enable_multi_connections_from_same_ip?: boolean;
    /**
     * True enables os cache
     */
    enable_os_cache?: boolean;
    /**
     * True enables sending of upload piece suggestions
     */
    enable_upload_suggestions?: boolean;
    /**
     * File pool size
     */
    file_pool_size?: number;
    /**
     * Maximal outgoing port (0: Disabled)
     */
    outgoing_ports_max?: number;
    /**
     * Minimal outgoing port (0: Disabled)
     */
    outgoing_ports_min?: number;
    /**
     * True rechecks torrents on completion
     */
    recheck_completed_torrents?: boolean;
    /**
     * True resolves peer countries
     */
    resolve_peer_countries?: boolean;
    /**
     * Save resume data interval in min
     */
    save_resume_data_interval?: number;
    /**
     * Send buffer low watermark in KiB
     */
    send_buffer_low_watermark?: number;
    /**
     * Send buffer watermark in KiB
     */
    send_buffer_watermark?: number;
    /**
     * Send buffer watermark factor in percent
     */
    send_buffer_watermark_factor?: number;
    /**
     * Socket backlog size
     */
    socket_backlog_size?: number;
    /**
     * Upload choking algorithm used (see list of possible values below)
     *
     * | Value | Description    |
     * | ----- | -------------- |
     * | 0     | Round-robin    |
     * | 1     | Fastest upload |
     * | 2     | Anti-leech     |
     *
     */
    upload_choking_algorithm?: 0 | 1 | 2;
    /**
     * Upload slots behavior used (see list of possible values below)
     *
     * | Value | Description       |
     * | ----- | ----------------- |
     * | 0     | Fixed slots       |
     * | 1     | Upload rate based |
     *
     */
    upload_slots_behavior?: 0 | 1;
    /**
     * UPnP lease duration (0: Permanent lease)
     */
    upnp_lease_duration?: number;
    /**
     * μTP-TCP mixed mode algorithm (see list of possible values below)
     *
     * | Value | Description       |
     * | ----- | ----------------- |
     * | 0     | Prefer TCP        |
     * | 1     | Peer proportional |
     *
     */
    utp_tcp_mixed_mode?: 0 | 1;
    [key: string]: unknown | string | boolean | number | {
        [key: string]: 0 | 1 | string;
    } | number | (0 | 1) | (0 | 1 | 2) | (0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9) | (0 | 1 | 2) | (-1 | 0 | 1 | 2 | 3 | 4 | 5) | Array<string> | Array<string> | (0 | 1) | (0 | 1 | 2) | (0 | 1) | (0 | 1) | undefined;
};

/**
 * A json object with key-value pairs of the settings you want to change and their new values.
 */
export type SetPreferences = Preferences & {
    /**
     * For API ≥ v2.3.0: Plaintext WebUI password, not readable, write-only. For API < v2.3.0: MD5 hash of WebUI password, hash is generated from the following string: `username:Web UI Access:plain_text_web_ui_password`
     */
    web_ui_password?: string;
};

export type MainLog = {
    /**
     * ID of the message
     */
    id?: number;
    /**
     * Text of the message
     */
    message?: string;
    /**
     * Milliseconds since epoch
     */
    timestamp?: number;
    /**
     * Type of the message: Log::NORMAL: `1`, Log::INFO: `2`, Log::WARNING: `4`, Log::CRITICAL: `8`
     */
    type?: 1 | 2 | 4 | 8;
};

export type PeersLog = {
    /**
     * ID of the peer
     */
    id?: number;
    /**
     * IP of the peer
     */
    ip?: string;
    /**
     * Milliseconds since epoch
     */
    timestamp?: number;
    /**
     * Whether or not the peer was blocked
     */
    blocked?: boolean;
    /**
     * Reason of the block
     */
    reason?: string;
};

/**
 * The response is a JSON object with the following possible fields
 */
export type MainData = {
    /**
     * Response ID
     */
    rid?: number;
    /**
     * Whether the response contains all the data or partial data
     */
    full_update?: boolean;
    /**
     * Property: torrent hash, value: same as [torrent list](https://github.com/qbittorrent/qBittorrent/wiki/WebUI-API-(qBittorrent-4.1)#get-torrent-list)
     */
    torrents?: {
        [key: string]: TorrentInfo;
    };
    /**
     * List of hashes of torrents removed since last request
     */
    torrents_removed?: Array<string>;
    /**
     * Info for categories added since last request
     */
    categories?: {
        [key: string]: TorrentsCategory;
    };
    /**
     * List of categories removed since last request
     */
    categories_removed?: Array<string>;
    /**
     * List of tags added since last request
     */
    tags?: Array<string>;
    /**
     * List of tags removed since last request
     */
    tags_removed?: Array<string>;
    server_state?: TransferInfo;
};

/**
 * The response is TODO
 */
export type TorrentPeers = {
    [key: string]: unknown;
};

/**
 * The response is a JSON object with the following fields
 *
 * In addition to the above in partial data requests (see [Get partial data](https://github.com/qbittorrent/qBittorrent/wiki/WebUI-API-(qBittorrent-4.1)#get-partial-data) for more info):
 *
 */
export type TransferInfo = {
    /**
     * Global download rate (bytes/s)
     */
    dl_info_speed?: number;
    /**
     * Data downloaded this session (bytes)
     */
    dl_info_data?: number;
    /**
     * Global upload rate (bytes/s)
     */
    up_info_speed?: number;
    /**
     * Data uploaded this session (bytes)
     */
    up_info_data?: number;
    /**
     * Download rate limit (bytes/s)
     */
    dl_rate_limit?: number;
    /**
     * Upload rate limit (bytes/s)
     */
    up_rate_limit?: number;
    /**
     * DHT nodes connected to
     */
    dht_nodes?: number;
    /**
     * Connection status. See possible values here below
     *
     * Possible values of connection_status:
     * | Value        |
     * | ------------ |
     * | connected    |
     * | firewalled   |
     * | disconnected |
     *
     */
    connection_status?: string;
    /**
     * True if torrent queueing is enabled
     */
    queueing?: boolean;
    /**
     * True if alternative speed limits are enabled
     */
    use_alt_speed_limits?: boolean;
    /**
     * Transfer list refresh interval (milliseconds)
     */
    refresh_interval?: number;
};

export type TorrentInfo = {
    /**
     * Time (Unix Epoch) when the torrent was added to the client
     */
    added_on?: number;
    /**
     * Amount of data left to download (bytes)
     */
    amount_left?: number;
    /**
     * Whether this torrent is managed by Automatic Torrent Management
     */
    auto_tmm?: boolean;
    /**
     * Percentage of file pieces currently available
     */
    availability?: number;
    /**
     * Category of the torrent
     */
    category?: string;
    /**
     * Amount of transfer data completed (bytes)
     */
    completed?: number;
    /**
     * Time (Unix Epoch) when the torrent completed
     */
    completion_on?: number;
    /**
     * Absolute path of torrent content (root path for multifile torrents, absolute file path for singlefile torrents)
     */
    content_path?: string;
    /**
     * Torrent download speed limit (bytes/s). `-1` if ulimited.
     */
    dl_limit?: number;
    /**
     * Torrent download speed (bytes/s)
     */
    dlspeed?: number;
    /**
     * Amount of data downloaded
     */
    downloaded?: number;
    /**
     * Amount of data downloaded this session
     */
    downloaded_session?: number;
    /**
     * Torrent ETA (seconds)
     */
    eta?: number;
    /**
     * True if first last piece are prioritized
     */
    f_l_piece_prio?: boolean;
    /**
     * True if force start is enabled for this torrent
     */
    force_start?: boolean;
    /**
     * Torrent hash
     */
    hash?: string;
    /**
     * Last time (Unix Epoch) when a chunk was downloaded/uploaded
     */
    last_activity?: number;
    /**
     * Magnet URI corresponding to this torrent
     */
    magnet_uri?: string;
    /**
     * Maximum share ratio until torrent is stopped from seeding/uploading
     */
    max_ratio?: number;
    /**
     * Maximum seeding time (seconds) until torrent is stopped from seeding
     */
    max_seeding_time?: number;
    /**
     * Torrent name
     */
    name?: string;
    /**
     * Number of seeds in the swarm
     */
    num_complete?: number;
    /**
     * Number of leechers in the swarm
     */
    num_incomplete?: number;
    /**
     * Number of leechers connected to
     */
    num_leechs?: number;
    /**
     * Number of seeds connected to
     */
    num_seeds?: number;
    /**
     * Torrent priority. Returns -1 if queuing is disabled or torrent is in seed mode
     */
    priority?: number;
    /**
     * Torrent progress (percentage/100)
     */
    progress?: number;
    /**
     * Torrent share ratio. Max ratio value: 9999.
     */
    ratio?: number;
    /**
     * TODO (what is different from max_ratio?)
     */
    ratio_limit?: number;
    /**
     * Path where this torrent's data is stored
     */
    save_path?: string;
    /**
     * Torrent elapsed time while complete (seconds)
     */
    seeding_time?: number;
    /**
     * TODO (what is different from `max_seeding_time`?) seeding_time_limit is a per torrent setting, when Automatic Torrent Management is disabled, furthermore then max_seeding_time is set to seeding_time_limit for this torrent. If Automatic Torrent Management is enabled, the value is -2. And if max_seeding_time is unset it have a default value -1.
     */
    seeding_time_limit?: number;
    /**
     * Time (Unix Epoch) when this torrent was last seen complete
     */
    seen_complete?: number;
    /**
     * True if sequential download is enabled
     */
    seq_dl?: boolean;
    /**
     * Total size (bytes) of files selected for download
     */
    size?: number;
    /**
     * Torrent state. See table here below for the possible values
     *
     * | Value              | Description                                                   |
     * | ------------------ | ------------------------------------------------------------- |
     * | error              | Some error occurred, applies to paused torrents               |
     * | missingFiles       | Torrent data files is missing                                 |
     * | uploading          | Torrent is being seeded and data is being transferred         |
     * | pausedUP           | Torrent is paused and has finished downloading                |
     * | queuedUP           | Queuing is enabled and torrent is queued for upload           |
     * | stalledUP          | Torrent is being seeded, but no connection were made          |
     * | checkingUP         | Torrent has finished downloading and is being checked         |
     * | forcedUP           | Torrent is forced to uploading and ignore queue limit         |
     * | allocating         | Torrent is allocating disk space for download                 |
     * | downloading        | Torrent is being downloaded and data is being transferred     |
     * | metaDL             | Torrent has just started downloading and is fetching metadata |
     * | pausedDL           | Torrent is paused and has NOT finished downloading            |
     * | queuedDL           | Queuing is enabled and torrent is queued for download         |
     * | stalledDL          | Torrent is being downloaded, but no connection were made      |
     * | checkingDL         | Same as checkingUP, but torrent has NOT finished downloading  |
     * | forcedDL           | Torrent is forced to downloading to ignore queue limit        |
     * | checkingResumeData | Checking resume data on qBt startup                           |
     * | moving             | Torrent is moving to another location                         |
     * | unknown            | Unknown status                                                |
     *
     */
    state?: 'error' | 'missingFiles' | 'uploading' | 'pausedUP' | 'queuedUP' | 'stalledUP' | 'checkingUP' | 'forcedUP' | 'allocating' | 'downloading' | 'metaDL' | 'pausedDL' | 'queuedDL' | 'stalledDL' | 'checkingDL' | 'forcedDL' | 'checkingResumeData' | 'moving' | 'unknown';
    /**
     * True if super seeding is enabled
     */
    super_seeding?: boolean;
    /**
     * Comma-concatenated tag list of the torrent
     */
    tags?: string;
    /**
     * Total active time (seconds)
     */
    time_active?: number;
    /**
     * Total size (bytes) of all file in this torrent (including unselected ones)
     */
    total_size?: number;
    /**
     * The first tracker with working status. Returns empty string if no tracker is working.
     */
    tracker?: string;
    /**
     * Torrent upload speed limit (bytes/s). `-1` if ulimited.
     */
    up_limit?: number;
    /**
     * Amount of data uploaded
     */
    uploaded?: number;
    /**
     * Amount of data uploaded this session
     */
    uploaded_session?: number;
    /**
     * Torrent upload speed (bytes/s)
     */
    upspeed?: number;
};

/**
 * The response is:
 * - empty, if the torrent hash is invalid
 * - otherwise, a JSON object with the following fields
 *
 * NB: `-1` is returned if the type of the property is integer but its value is not known.
 *
 */
export type TorrentsProperties = {
    /**
     * Torrent save path
     */
    save_path?: string;
    /**
     * Torrent creation date (Unix timestamp)
     */
    creation_date?: number;
    /**
     * Torrent piece size (bytes)
     */
    piece_size?: number;
    /**
     * Torrent comment
     */
    comment?: string;
    /**
     * Total data wasted for torrent (bytes)
     */
    total_wasted?: number;
    /**
     * Total data uploaded for torrent (bytes)
     */
    total_uploaded?: number;
    /**
     * Total data uploaded this session (bytes)
     */
    total_uploaded_session?: number;
    /**
     * Total data downloaded for torrent (bytes)
     */
    total_downloaded?: number;
    /**
     * Total data downloaded this session (bytes)
     */
    total_downloaded_session?: number;
    /**
     * Torrent upload limit (bytes/s)
     */
    up_limit?: number;
    /**
     * Torrent download limit (bytes/s)
     */
    dl_limit?: number;
    /**
     * Torrent elapsed time (seconds)
     */
    time_elapsed?: number;
    /**
     * Torrent elapsed time while complete (seconds)
     */
    seeding_time?: number;
    /**
     * Torrent connection count
     */
    nb_connections?: number;
    /**
     * Torrent connection count limit
     */
    nb_connections_limit?: number;
    /**
     * Torrent share ratio
     */
    share_ratio?: number;
    /**
     * When this torrent was added (unix timestamp)
     */
    addition_date?: number;
    /**
     * Torrent completion date (unix timestamp)
     */
    completion_date?: number;
    /**
     * Torrent creator
     */
    created_by?: string;
    /**
     * Torrent average download speed (bytes/second)
     */
    dl_speed_avg?: number;
    /**
     * Torrent download speed (bytes/second)
     */
    dl_speed?: number;
    /**
     * Torrent ETA (seconds)
     */
    eta?: number;
    /**
     * Last seen complete date (unix timestamp)
     */
    last_seen?: number;
    /**
     * Number of peers connected to
     */
    peers?: number;
    /**
     * Number of peers in the swarm
     */
    peers_total?: number;
    /**
     * Number of pieces owned
     */
    pieces_have?: number;
    /**
     * Number of pieces of the torrent
     */
    pieces_num?: number;
    /**
     * Number of seconds until the next announce
     */
    reannounce?: number;
    /**
     * Number of seeds connected to
     */
    seeds?: number;
    /**
     * Number of seeds in the swarm
     */
    seeds_total?: number;
    /**
     * Torrent total size (bytes)
     */
    total_size?: number;
    /**
     * Torrent average upload speed (bytes/second)
     */
    up_speed_avg?: number;
    /**
     * Torrent upload speed (bytes/second)
     */
    up_speed?: number;
};

export type TorrentsTrackers = {
    /**
     * Tracker url
     */
    url?: string;
    /**
     * Tracker status. See the table below for possible values
     *
     * | Value | Description                                                                        |
     * | ----- | ---------------------------------------------------------------------------------- |
     * | 0     | Tracker is disabled (used for DHT, PeX, and LSD)                                   |
     * | 1     | Tracker has not been contacted yet                                                 |
     * | 2     | Tracker has been contacted and is working                                          |
     * | 3     | Tracker is updating                                                                |
     * | 4     | Tracker has been contacted, but it is not working (or doesn't send proper replies) |
     *
     */
    status?: 0 | 1 | 2 | 3 | 4;
    /**
     * Tracker priority tier. Lower tier trackers are tried before higher tiers. Tier numbers are valid when `>= 0`, `< 0` is used as placeholder when `tier` does not exist for special entries (such as DHT).
     */
    tier?: number;
    /**
     * Number of peers for current torrent, as reported by the tracker
     */
    num_peers?: number;
    /**
     * Number of seeds for current torrent, asreported by the tracker
     */
    num_seeds?: number;
    /**
     * Number of leeches for current torrent, as reported by the tracker
     */
    num_leeches?: number;
    /**
     * Number of completed downlods for current torrent, as reported by the tracker
     */
    num_downloaded?: number;
    /**
     * Tracker message (there is no way of knowing what this message is - it's up to tracker admins)
     */
    msg?: string;
};

export type TorrentsWebseeds = {
    /**
     * URL of the web seed
     */
    url?: string;
};

export type TorrentsFiles = {
    /**
     * File index
     */
    index?: number;
    /**
     * File name (including relative path)
     */
    name?: string;
    /**
     * File size (bytes)
     */
    size?: number;
    /**
     * File progress (percentage/100)
     */
    progress?: number;
    /**
     * File priority. See possible values here below
     *
     * | Value | Description      |
     * | ----- | ---------------- |
     * | 0     | Do not download  |
     * | 1     | Normal priority  |
     * | 6     | High priority    |
     * | 7     | Maximal priority |
     *
     */
    priority?: 0 | 1 | 6 | 7;
    /**
     * True if file is seeding/complete
     */
    is_seed?: boolean;
    /**
     * The first number is the starting piece index and the second number is the ending piece index (inclusive)
     */
    piece_range?: Array<number>;
    /**
     * Percentage of file pieces currently available (percentage/100)
     */
    availability?: number;
};

export type Hashes = {
    hashes: Array<string>;
};

export type AddTorrentsUrls = {
    /**
     * URLs separated with newlines
     */
    urls: string;
} & AddTorrentsCommon;

export type AddTorrentsFiles = {
    /**
     * Raw data of torrent file. `torrents` can be presented multiple times.
     */
    torrents: Array<Blob | File>;
} & AddTorrentsCommon;

export type AddTorrentsCommon = {
    /**
     * Download folder
     */
    savepath?: string;
    /**
     * Cookie sent to download the .torrent file
     */
    cookie?: string;
    /**
     * Category for the torrent
     */
    category?: string;
    /**
     * Tags for the torrent, split by ','
     */
    tags?: Array<string>;
    /**
     * Skip hash checking. Possible values are `true`, `false` (default)
     */
    skip_checking?: 'true' | 'false';
    /**
     * Add torrents in the paused state. Possible values are `true`, `false` (default)
     */
    paused?: 'true' | 'false';
    /**
     * Create the root folder. Possible values are `true`, `false`, unset (default)
     */
    root_folder?: 'true' | 'false' | 'unset';
    /**
     * Rename torrent
     */
    rename?: string;
    /**
     * Set torrent upload speed limit. Unit in bytes/second
     */
    upLimit?: number;
    /**
     * Set torrent download speed limit. Unit in bytes/second
     */
    dlLimit?: number;
    /**
     * Set torrent share ratio limit
     */
    ratioLimit?: number;
    /**
     * Set torrent seeding time limit. Unit in seconds
     */
    seedingTimeLimit?: number;
    /**
     * Whether Automatic Torrent Management should be used
     */
    autoTMM?: boolean;
    /**
     * Enable sequential download. Possible values are `true`, `false` (default)
     */
    sequentialDownload?: 'true' | 'false';
    /**
     * Prioritize download first last piece. Possible values are `true`, `false` (default)
     */
    firstLastPiecePrio?: 'true' | 'false';
};

export type TorrentsLimit = {
    [key: string]: number;
};

export type SetTorrentsLimit = Hashes & {
    limit: number;
};

export type TorrentsCategory = {
    name?: string;
    savePath?: string;
};

export type Category = {
    category: string;
    savePath: string;
};

export type TorrentsTags = Hashes & {
    tags: Array<string>;
};

export type SetTorrentsValue = Hashes & {
    /**
     * `value` is a boolean, affects the torrents listed in `hashes`, default is `false`
     */
    value: boolean;
};

export type RenameTorrentFiles = {
    /**
     * The hash of the torrent
     */
    hash: string;
    /**
     * The old path of the torrent
     */
    oldPath: string;
    /**
     * The new path to use for the file
     */
    newPath: string;
};

/**
 * JSON encoded rule definition
 *
 * Rule definition is JSON encoded dictionary with the following fields:
 * | Field                     | Type   | Description                                             |
 * | ------------------------- | ------ | ------------------------------------------------------- |
 * | enabled                   | bool   | Whether the rule is enabled                             |
 * | mustContain               | string | The substring that the torrent name must contain        |
 * | mustNotContain            | string | The substring that the torrent name must not contain    |
 * | useRegex                  | bool   | Enable regex mode in "mustContain" and "mustNotContain" |
 * | episodeFilter             | string | Episode filter definition                               |
 * | smartFilter               | bool   | Enable smart episode filter                             |
 * | previouslyMatchedEpisodes | list   | The list of episode IDs already matched by smart filter |
 * | affectedFeeds             | list   | The feed URLs the rule applied to                       |
 * | ignoreDays                | number | Ignore sunsequent rule matches                          |
 * | lastMatch                 | string | The rule last match time                                |
 * | addPaused                 | bool   | Add matched torrent in paused mode                      |
 * | assignedCategory          | string | Assign category to the torrent                          |
 * | savePath                  | string | Save torrent to the given directory                     |
 *
 */
export type RssRuleDef = {
    /**
     * Whether the rule is enabled
     */
    enabled?: boolean;
    /**
     * The substring that the torrent name must contain
     */
    mustContain?: string;
    /**
     * The substring that the torrent name must not contain
     */
    mustNotContain?: string;
    /**
     * Enable regex mode in "mustContain" and "mustNotContain"
     */
    useRegex?: boolean;
    /**
     * Episode filter definition
     */
    episodeFilter?: string;
    /**
     * Enable smart episode filter
     */
    smartFilter?: boolean;
    /**
     * The list of episode IDs already matched by smart filter
     */
    previouslyMatchedEpisodes?: Array<number>;
    /**
     * The feed URLs the rule applied to
     */
    affectedFeeds?: Array<string>;
    /**
     * Ignore sunsequent rule matches
     */
    ignoreDays?: number;
    /**
     * The rule last match time
     */
    lastMatch?: string;
    /**
     * Add matched torrent in paused mode
     */
    addPaused?: boolean;
    /**
     * Assign category to the torrent
     */
    assignedCategory?: string;
    /**
     * Save torrent to the given directory
     */
    savePath?: string;
};

/**
 * The response is a JSON object with the following fields
 */
export type SearchJob = {
    /**
     * ID of the search job
     */
    id?: number;
};

export type SearchJobStatus = SearchJob & {
    /**
     * Current status of the search job (either `Running` or `Stopped`)
     */
    status?: 'Running' | 'Stopped';
    /**
     * Total number of results. If the status is `Running` this number may contineu to increase
     */
    total?: number;
};

export type SearchResult = {
    /**
     * URL of the torrent's description page
     */
    descrLink?: string;
    /**
     * Name of the file
     */
    fileName?: string;
    /**
     * Size of the file in Bytes
     */
    fileSize?: number;
    /**
     * Torrent download link (usually either .torrent file or magnet link)
     */
    fileUrl?: string;
    /**
     * Number of leechers
     */
    nbLeechers?: number;
    /**
     * Number of seeders
     */
    nbSeeders?: number;
    /**
     * URL of the torrent site
     */
    siteUrl?: string;
};

export type SearchResults = {
    results?: Array<SearchResult>;
    /**
     * Current status of the search job (either `Running` or `Stopped`)
     */
    status?: 'Running' | 'Stopped';
    /**
     * Total number of results. If the status is `Running` this number may continue to increase
     */
    total?: number;
};

export type SearchPlugin = {
    /**
     * Whether the plugin is enabled
     */
    enabled?: boolean;
    /**
     * Full name of the plugin
     */
    fullName?: string;
    /**
     * Short name of the plugin
     */
    name?: string;
    /**
     * List of category objects
     */
    supportedCategories?: Array<{
        id?: string;
        name?: string;
    }>;
    /**
     * URL of the torrent site
     */
    url?: string;
    /**
     * Installed version of the plugin
     */
    version?: string;
};

export type AuthLoginPostData = {
    /**
     * Example showing how to login and execute a command that requires authentication using `curl`:
     *
     * ```
     * $ curl -i --header 'Referer: http://localhost:8080' --data 'username=admin&password=adminadmin' http://localhost:8080/api/v2/auth/login
     * HTTP/1.1 200 OK
     * Content-Encoding:
     * Content-Length: 3
     * Content-Type: text/plain; charset=UTF-8
     * Set-Cookie: SID=hBc7TxF76ERhvIw0jQQ4LZ7Z1jQUV0tQ; path=/
     * $ curl http://localhost:8080/api/v2/torrents/info --cookie "SID=hBc7TxF76ERhvIw0jQQ4LZ7Z1jQUV0tQ"
     * ```
     *
     * Note: Set `Referer` or `Origin` header to the exact same domain and port as used in the HTTP query `Host` header.
     *
     */
    body: {
        username: string;
        password: string;
    };
    headers?: {
        Referer?: string;
        Origin?: string;
    };
    path?: never;
    query?: never;
    url: '/auth/login';
};

export type AuthLoginPostErrors = {
    /**
     * User's IP is banned for too many failed login attempts
     */
    403: unknown;
};

export type AuthLoginPostResponses = {
    /**
     * All other scenarios
     */
    200: string;
};

export type AuthLoginPostResponse = AuthLoginPostResponses[keyof AuthLoginPostResponses];

export type AuthLogoutPostData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/auth/logout';
};

export type AuthLogoutPostResponses = {
    /**
     * All scenarios
     */
    200: unknown;
};

export type AppVersionGetData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/app/version';
};

export type AppVersionGetResponses = {
    /**
     * The response is a string with the application version, e.g. `v4.1.3`
     */
    200: string;
};

export type AppVersionGetResponse = AppVersionGetResponses[keyof AppVersionGetResponses];

export type AppWebapiVersionGetData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/app/webapiVersion';
};

export type AppWebapiVersionGetResponses = {
    /**
     * The response is a string with the WebAPI version, e.g. `2.0`
     */
    200: string;
};

export type AppWebapiVersionGetResponse = AppWebapiVersionGetResponses[keyof AppWebapiVersionGetResponses];

export type AppBuildInfoGetData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/app/buildInfo';
};

export type AppBuildInfoGetResponses = {
    /**
     * All scenarios- see JSON below
     */
    200: BuildInfo;
};

export type AppBuildInfoGetResponse = AppBuildInfoGetResponses[keyof AppBuildInfoGetResponses];

export type AppShutdownGetData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/app/shutdown';
};

export type AppShutdownGetResponses = {
    /**
     * All scenarios
     */
    200: unknown;
};

export type AppPreferencesGetData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/app/preferences';
};

export type AppPreferencesGetResponses = {
    /**
     * All scenarios- see JSON below
     */
    200: Preferences;
};

export type AppPreferencesGetResponse = AppPreferencesGetResponses[keyof AppPreferencesGetResponses];

export type AppSetPreferencesPostData = {
    body: {
        json: SetPreferences;
    };
    path?: never;
    query?: never;
    url: '/app/setPreferences';
};

export type AppSetPreferencesPostResponses = {
    /**
     * All scenarios
     */
    200: unknown;
};

export type AppDefaultSavePathGetData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/app/defaultSavePath';
};

export type AppDefaultSavePathGetResponses = {
    /**
     * The response is a string with the default save path, e.g. `C:/Users/Dayman/Downloads`.
     */
    200: string;
};

export type AppDefaultSavePathGetResponse = AppDefaultSavePathGetResponses[keyof AppDefaultSavePathGetResponses];

export type LogMainPostData = {
    body: {
        /**
         * Include normal messages (default: `true`)
         */
        normal: boolean;
        /**
         * Include info messages (default: `true`)
         */
        info: boolean;
        /**
         * Include warning messages (default: `true`)
         */
        warning: boolean;
        /**
         * Include critical messages (default: `true`)
         */
        critical: boolean;
        /**
         * Exclude messages with "message id" <= `last_known_id` (default: `-1`)
         */
        last_known_id: number;
    };
    path?: never;
    query?: never;
    url: '/log/main';
};

export type LogMainPostResponses = {
    /**
     * The response is a JSON array in which each element is an entry of the log.
     *
     * Each element of the array has the following properties:
     *
     */
    200: Array<MainLog>;
};

export type LogMainPostResponse = LogMainPostResponses[keyof LogMainPostResponses];

export type LogPeersPostData = {
    body: {
        /**
         * Exclude messages with "message id" <= `last_known_id` (default: `-1`)
         */
        last_known_id: number;
    };
    path?: never;
    query?: never;
    url: '/log/peers';
};

export type LogPeersPostResponses = {
    /**
     * The response a JSON array. Each element of the array of objects (each object is the information relative to a peer) containing the following fields
     */
    200: Array<PeersLog>;
};

export type LogPeersPostResponse = LogPeersPostResponses[keyof LogPeersPostResponses];

export type SyncMaindataPostData = {
    body: {
        /**
         * Response ID. If not provided, `rid=0` will be assumed. If the given `rid` is different from the one of last server reply, `full_update` will be `true` (see the server reply details for more info)
         */
        rid?: number;
    };
    path?: never;
    query?: never;
    url: '/sync/maindata';
};

export type SyncMaindataPostResponses = {
    /**
     * All scenarios- see JSON below
     */
    200: MainData;
};

export type SyncMaindataPostResponse = SyncMaindataPostResponses[keyof SyncMaindataPostResponses];

export type SyncTorrentPeersPostData = {
    body: {
        /**
         * Torrent hash
         */
        hash: string;
        /**
         * Response ID. If not provided, `rid=0` will be assumed. If the given `rid` is different from the one of last server reply, `full_update` will be `true` (see the server reply details for more info)
         */
        rid?: number;
    };
    path?: never;
    query?: never;
    url: '/sync/torrentPeers';
};

export type SyncTorrentPeersPostErrors = {
    /**
     * Torrent hash was not found
     */
    404: unknown;
};

export type SyncTorrentPeersPostResponses = {
    /**
     * All other scenarios- see JSON below
     */
    200: TorrentPeers;
};

export type SyncTorrentPeersPostResponse = SyncTorrentPeersPostResponses[keyof SyncTorrentPeersPostResponses];

export type TransferInfoGetData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/transfer/info';
};

export type TransferInfoGetResponses = {
    /**
     * All scenarios- see JSON below
     */
    200: TransferInfo;
};

export type TransferInfoGetResponse = TransferInfoGetResponses[keyof TransferInfoGetResponses];

export type TransferSpeedLimitsModeGetData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/transfer/speedLimitsMode';
};

export type TransferSpeedLimitsModeGetResponses = {
    /**
     * The response is `1` if alternative speed limits are enabled, `0` otherwise.
     */
    200: 0 | 1;
};

export type TransferSpeedLimitsModeGetResponse = TransferSpeedLimitsModeGetResponses[keyof TransferSpeedLimitsModeGetResponses];

export type TransferToggleSpeedLimitsModeGetData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/transfer/toggleSpeedLimitsMode';
};

export type TransferToggleSpeedLimitsModeGetResponses = {
    /**
     * All scenarios
     */
    200: unknown;
};

export type TransferDownloadLimitGetData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/transfer/downloadLimit';
};

export type TransferDownloadLimitGetResponses = {
    /**
     * The response is the value of current global download speed limit in bytes/second; this value will be zero if no limit is applied.
     */
    200: number;
};

export type TransferDownloadLimitGetResponse = TransferDownloadLimitGetResponses[keyof TransferDownloadLimitGetResponses];

export type TransferSetDownloadLimitPostData = {
    body: {
        /**
         * The global download speed limit to set in bytes/second
         */
        limit?: number;
    };
    path?: never;
    query?: never;
    url: '/transfer/setDownloadLimit';
};

export type TransferSetDownloadLimitPostResponses = {
    /**
     * All scenarios
     */
    200: unknown;
};

export type TransferUploadLimitGetData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/transfer/uploadLimit';
};

export type TransferUploadLimitGetResponses = {
    /**
     * The response is the value of current global upload speed limit in bytes/second; this value will be zero if no limit is applied.
     */
    200: number;
};

export type TransferUploadLimitGetResponse = TransferUploadLimitGetResponses[keyof TransferUploadLimitGetResponses];

export type TransferSetUploadLimitPostData = {
    body: {
        /**
         * The global upload speed limit to set in bytes/second
         */
        limit?: number;
    };
    path?: never;
    query?: never;
    url: '/transfer/setUploadLimit';
};

export type TransferSetUploadLimitPostResponses = {
    /**
     * All scenarios
     */
    200: unknown;
};

export type TransferBanPeersPostData = {
    body: {
        /**
         * The peer to ban, or multiple peers separated by a pipe `|`. Each peer is a colon-separated `host:port`
         */
        peers?: Array<string>;
    };
    path?: never;
    query?: never;
    url: '/transfer/banPeers';
};

export type TransferBanPeersPostResponses = {
    /**
     * All scenarios
     */
    200: unknown;
};

export type TorrentsInfoPostData = {
    body: {
        /**
         * Filter torrent list by state. Allowed state filters: `all`, `downloading`, `seeding`, `completed`, `paused`, `active`, `inactive`, `resumed`, `stalled`, `stalled_uploading`, `stalled_downloading`, `errored`
         */
        filter?: 'all' | 'downloading' | 'seeding' | 'completed' | 'paused' | 'active' | 'inactive' | 'resumed' | 'stalled' | 'stalled_uploading' | 'stalled_downloading' | 'errored';
        /**
         * Get torrents with the given category (empty string means "without category"; no "category" parameter means "any category" <- broken until [#11748](https://github.com/qbittorrent/qBittorrent/issues/11748) is resolved). Remember to URL-encode the category name. For example, `My category` becomes `My%20category`
         */
        category?: string;
        /**
         * Get torrents with the given tag (empty string means "without tag"; no "tag" parameter means "any tag". Remember to URL-encode the category name. For example, `My tag` becomes `My%20tag`
         */
        tag?: string;
        /**
         * Sort torrents by given key. They can be sorted using any field of the response's JSON array (which are documented below) as the sort key.
         */
        sort?: string;
        /**
         * Enable reverse sorting. Defaults to `false`
         */
        reverse?: boolean;
        /**
         * Limit the number of torrents returned
         */
        limit?: number;
        /**
         * Set offset (if less than 0, offset from end)
         */
        offset?: number;
        /**
         * Filter by hashes. Can contain multiple hashes separated by `|`
         */
        hashes?: Array<string>;
    };
    path?: never;
    query?: never;
    url: '/torrents/info';
};

export type TorrentsInfoPostResponses = {
    /**
     * The response is a JSON array with the following fields
     */
    200: Array<TorrentInfo>;
};

export type TorrentsInfoPostResponse = TorrentsInfoPostResponses[keyof TorrentsInfoPostResponses];

export type TorrentsPropertiesPostData = {
    body: {
        /**
         * The hash of the torrent you want to get the generic properties of
         */
        hash: string;
    };
    path?: never;
    query?: never;
    url: '/torrents/properties';
};

export type TorrentsPropertiesPostErrors = {
    /**
     * Torrent hash was not found
     */
    404: unknown;
};

export type TorrentsPropertiesPostResponses = {
    /**
     * All other scenarios- see JSON below
     */
    200: TorrentsProperties;
};

export type TorrentsPropertiesPostResponse = TorrentsPropertiesPostResponses[keyof TorrentsPropertiesPostResponses];

export type TorrentsTrackersPostData = {
    body: {
        /**
         * The hash of the torrent you want to get the trackers of
         */
        hash: string;
    };
    path?: never;
    query?: never;
    url: '/torrents/trackers';
};

export type TorrentsTrackersPostErrors = {
    /**
     * Torrent hash was not found
     */
    404: unknown;
};

export type TorrentsTrackersPostResponses = {
    /**
     * The response is a JSON array, where each element contains info about one tracker, with the following fields
     */
    200: Array<TorrentsTrackers>;
};

export type TorrentsTrackersPostResponse = TorrentsTrackersPostResponses[keyof TorrentsTrackersPostResponses];

export type TorrentWebseedsPostData = {
    body: {
        /**
         * The hash of the torrent you want to get the webseeds of
         */
        hash: string;
    };
    path?: never;
    query?: never;
    url: '/torrents/webseeds';
};

export type TorrentWebseedsPostErrors = {
    /**
     * Torrent hash was not found
     */
    404: unknown;
};

export type TorrentWebseedsPostResponses = {
    /**
     * The response is a JSON array, where each element is information about one webseed, with the following fields
     */
    200: Array<TorrentsWebseeds>;
};

export type TorrentWebseedsPostResponse = TorrentWebseedsPostResponses[keyof TorrentWebseedsPostResponses];

export type TorrentsFilesPostData = {
    body: {
        /**
         * The hash of the torrent you want to get the contents of
         */
        hash: string;
        /**
         * The indexes of the files you want to retrieve. `indexes` can contain multiple values separated by `|`.
         */
        indexes?: Array<string>;
    };
    path?: never;
    query?: never;
    url: '/torrents/files';
};

export type TorrentsFilesPostErrors = {
    /**
     * Torrent hash was not found
     */
    404: unknown;
};

export type TorrentsFilesPostResponses = {
    /**
     * The response is:
     * - empty, if the torrent hash is invalid
     * - otherwise, a JSON array, where each element contains info about one file, with the following fields
     *
     */
    200: Array<TorrentsFiles>;
};

export type TorrentsFilesPostResponse = TorrentsFilesPostResponses[keyof TorrentsFilesPostResponses];

export type TorrentsPieceStatesPostData = {
    body: {
        /**
         * The hash of the torrent you want to get the pieces' states of
         */
        hash: string;
    };
    path?: never;
    query?: never;
    url: '/torrents/pieceStates';
};

export type TorrentsPieceStatesPostErrors = {
    /**
     * Torrent hash was not found
     */
    404: unknown;
};

export type TorrentsPieceStatesPostResponses = {
    /**
     * The response is:
     * - empty, if the torrent hash is invalid
     * - otherwise, an array of states (integers) of all pieces (in order) of a specific torrent.
     *
     * Value meanings are defined as below:
     * | Value | Description        |
     * | ----- | ------------------ |
     * | 0     | Not downloaded yet |
     * | 1     | Now downloading    |
     * | 2     | Already downloaded |
     *
     */
    200: Array<0 | 1 | 2>;
};

export type TorrentsPieceStatesPostResponse = TorrentsPieceStatesPostResponses[keyof TorrentsPieceStatesPostResponses];

export type TorrentsPieceHashesPostData = {
    body: {
        /**
         * The hash of the torrent you want to get the pieces' hashes of
         */
        hash: string;
    };
    path?: never;
    query?: never;
    url: '/torrents/pieceHashes';
};

export type TorrentsPieceHashesPostErrors = {
    /**
     * Torrent hash was not found
     */
    404: unknown;
};

export type TorrentsPieceHashesPostResponses = {
    /**
     * The response is:
     * - empty, if the torrent hash is invalid
     * - otherwise, an array of hashes (strings) of all pieces (in order) of a specific torrent.
     *
     */
    200: Array<string>;
};

export type TorrentsPieceHashesPostResponse = TorrentsPieceHashesPostResponses[keyof TorrentsPieceHashesPostResponses];

export type TorrentsPausePostData = {
    /**
     * The hashes of the torrents you want to pause. `hashes` can contain multiple hashes separated by `|`, to pause multiple torrents, or set to `all`, to pause all torrents.
     */
    body: Hashes;
    path?: never;
    query?: never;
    url: '/torrents/pause';
};

export type TorrentsPausePostResponses = {
    /**
     * All scenarios
     */
    200: unknown;
};

export type TorrentsResumePostData = {
    /**
     * The hashes of the torrents you want to resume. `hashes` can contain multiple hashes separated by `|`, to resume multiple torrents, or set to `all`, to resume all torrents.
     */
    body: Hashes;
    path?: never;
    query?: never;
    url: '/torrents/resume';
};

export type TorrentsResumePostResponses = {
    /**
     * All scenarios
     */
    200: unknown;
};

export type TorrentsDeletePostData = {
    /**
     * The hashes of the torrents you want to delete. `hashes` can contain multiple hashes separated by `|`, to delete multiple torrents, or set to `all`, to delete all torrents.
     */
    body: Hashes & {
        /**
         * If set to `true`, the downloaded data will also be deleted, otherwise has no effect.
         */
        deleteFiles: boolean;
    };
    path?: never;
    query?: never;
    url: '/torrents/delete';
};

export type TorrentsDeletePostResponses = {
    /**
     * All scenarios
     */
    200: unknown;
};

export type TorrentsRecheckPostData = {
    /**
     * The hashes of the torrents you want to recheck. `hashes` can contain multiple hashes separated by `|`, to recheck multiple torrents, or set to `all`, to recheck all torrents.
     */
    body: Hashes;
    path?: never;
    query?: never;
    url: '/torrents/recheck';
};

export type TorrentsRecheckPostResponses = {
    /**
     * All scenarios
     */
    200: unknown;
};

export type TorrentsReannouncePostData = {
    /**
     * The hashes of the torrents you want to reannounce. `hashes` can contain multiple hashes separated by `|`, to reannounce multiple torrents, or set to `all`, to reannounce all torrents.
     */
    body: Hashes;
    path?: never;
    query?: never;
    url: '/torrents/reannounce';
};

export type TorrentsReannouncePostResponses = {
    /**
     * All scenarios
     */
    200: unknown;
};

export type TorrentsAddPostData = {
    /**
     * Add torrent from URLs example:
     * ```
     * POST /api/v2/torrents/add HTTP/1.1
     * User-Agent: Fiddler
     * Host: 127.0.0.1
     * Cookie: SID=your_sid
     * Content-Type: multipart/form-data; boundary=---------------------------6688794727912
     * Content-Length: length
     *
     * -----------------------------6688794727912
     * Content-Disposition: form-data; name="urls"
     *
     * https://torcache.net/torrent/3B1A1469C180F447B77021074DBBCCAEF62611E7.torrent
     * https://torcache.net/torrent/3B1A1469C180F447B77021074DBBCCAEF62611E8.torrent
     * -----------------------------6688794727912
     * Content-Disposition: form-data; name="savepath"
     *
     * C:/Users/qBit/Downloads
     * -----------------------------6688794727912
     * Content-Disposition: form-data; name="cookie"
     *
     * ui=28979218048197
     * -----------------------------6688794727912
     * Content-Disposition: form-data; name="category"
     *
     * movies
     * -----------------------------6688794727912
     * Content-Disposition: form-data; name="skip_checking"
     *
     * true
     * -----------------------------6688794727912
     * Content-Disposition: form-data; name="paused"
     *
     * true
     * -----------------------------6688794727912
     * Content-Disposition: form-data; name="root_folder"
     *
     * true
     * -----------------------------6688794727912--
     * ```
     *
     * Add torrents from files example:
     * ```
     * POST /api/v2/torrents/add HTTP/1.1
     * Content-Type: multipart/form-data; boundary=-------------------------acebdf13572468
     * User-Agent: Fiddler
     * Host: 127.0.0.1
     * Cookie: SID=your_sid
     * Content-Length: length
     *
     * ---------------------------acebdf13572468
     * Content-Disposition: form-data; name="torrents"; filename="8f18036b7a205c9347cb84a253975e12f7adddf2.torrent"
     * Content-Type: application/x-bittorrent
     *
     * file_binary_data_goes_here
     * ---------------------------acebdf13572468
     * Content-Disposition: form-data; name="torrents"; filename="UFS.torrent"
     * Content-Type: application/x-bittorrent
     *
     * file_binary_data_goes_here
     * ---------------------------acebdf13572468--
     * ```
     * The above example will add two torrent files. `file_binary_data_goes_here` represents raw data of torrent file (basically a byte array).
     *
     */
    body: AddTorrentsUrls | AddTorrentsFiles;
    path?: never;
    query?: never;
    url: '/torrents/add';
};

export type TorrentsAddPostErrors = {
    /**
     * Torrent file is not valid
     */
    415: unknown;
};

export type TorrentsAddPostResponses = {
    /**
     * All other scenarios
     */
    200: unknown;
};

export type TorrentsAddTrackersPostData = {
    /**
     * ```
     * POST /api/v2/torrents/addTrackers HTTP/1.1
     * User-Agent: Fiddler
     * Host: 127.0.0.1
     * Cookie: SID=your_sid
     * Content-Type: application/x-www-form-urlencoded
     * Content-Length: length
     *
     * hash=8c212779b4abde7c6bc608063a0d008b7e40ce32&urls=http://192.168.0.1/announce%0Audp://192.168.0.1:3333/dummyAnnounce
     * ```
     * This adds two trackers to torrent with hash `8c212779b4abde7c6bc608063a0d008b7e40ce32`. Note `%0A` (aka LF newline) between trackers. Ampersand in tracker urls MUST be escaped.
     *
     */
    body: {
        hash: string;
        urls: string;
    };
    path?: never;
    query?: never;
    url: '/torrents/addTrackers';
};

export type TorrentsAddTrackersPostErrors = {
    /**
     * Torrent hash was not found
     */
    404: unknown;
};

export type TorrentsAddTrackersPostResponses = {
    /**
     * All other scenarios- see JSON below
     */
    200: unknown;
};

export type TorrentsEditTrackerPostData = {
    body: {
        /**
         * The hash of the torrent
         */
        hash: string;
        /**
         * The tracker URL you want to edit
         */
        origUrl: string;
        /**
         * The new URL to replace the `origUrl`
         */
        newUrl: string;
    };
    path?: never;
    query?: never;
    url: '/torrents/editTracker';
};

export type TorrentsEditTrackerPostErrors = {
    /**
     * `newUrl` is not a valid URL
     */
    400: unknown;
    /**
     * Torrent hash was not found
     */
    404: unknown;
    /**
     * `newUrl` already exists for the torrent or `origUrl` was not found
     */
    409: unknown;
};

export type TorrentsEditTrackerPostResponses = {
    /**
     * All other scenarios
     */
    200: unknown;
};

export type TorrentsRemoveTrackersPostData = {
    body: {
        /**
         * The hash of the torrent
         */
        hash: string;
        /**
         * URLs to remove, separated by `|`
         */
        urls: Array<string>;
    };
    path?: never;
    query?: never;
    url: '/torrents/removeTrackers';
};

export type TorrentsRemoveTrackersPostErrors = {
    /**
     * Torrent hash was not found
     */
    404: unknown;
    /**
     * All `urls` were not found
     */
    409: unknown;
};

export type TorrentsRemoveTrackersPostResponses = {
    /**
     * All other scenarios
     */
    200: unknown;
};

export type TorrentsAddPeersPostData = {
    body: {
        /**
         * The hash of the torrent, or multiple hashes separated by a pipe `|`
         */
        hashes: Array<string>;
        /**
         * The peer to add, or multiple peers separated by a pipe `|`. Each peer is a colon-separated `host:port`
         */
        peers: Array<string>;
    };
    path?: never;
    query?: never;
    url: '/torrents/addPeers';
};

export type TorrentsAddPeersPostErrors = {
    /**
     * None of the supplied peers are valid
     */
    400: unknown;
};

export type TorrentsAddPeersPostResponses = {
    /**
     * All other scenarios
     */
    200: unknown;
};

export type TorrentsIncreasePrioPostData = {
    /**
     * The hashes of the torrents you want to increase the priority of. `hashes` can contain multiple hashes separated by `|`, to increase the priority of multiple torrents, or set to `all`, to increase the priority of all torrents.
     */
    body: Hashes;
    path?: never;
    query?: never;
    url: '/torrents/increasePrio';
};

export type TorrentsIncreasePrioPostErrors = {
    /**
     * Torrent queueing is not enabled
     */
    409: unknown;
};

export type TorrentsIncreasePrioPostResponses = {
    /**
     * All other scenarios
     */
    200: unknown;
};

export type TorrentsDecreasePrioPostData = {
    /**
     * The hashes of the torrents you want to decrease the priority of. `hashes` can contain multiple hashes separated by `|`, to decrease the priority of multiple torrents, or set to `all`, to decrease the priority of all torrents.
     */
    body: Hashes;
    path?: never;
    query?: never;
    url: '/torrents/decreasePrio';
};

export type TorrentsDecreasePrioPostErrors = {
    /**
     * Torrent queueing is not enabled
     */
    409: unknown;
};

export type TorrentsDecreasePrioPostResponses = {
    /**
     * All other scenarios
     */
    200: unknown;
};

export type TorrentsTopPrioPostData = {
    /**
     * The hashes of the torrents you want to set to the maximum priority. `hashes` can contain multiple hashes separated by `|`, to set multiple torrents to the maximum priority, or set to `all`, to set all torrents to the maximum priority.
     */
    body: Hashes;
    path?: never;
    query?: never;
    url: '/torrents/topPrio';
};

export type TorrentsTopPrioPostErrors = {
    /**
     * Torrent queueing is not enabled
     */
    409: unknown;
};

export type TorrentsTopPrioPostResponses = {
    /**
     * All other scenarios
     */
    200: unknown;
};

export type TorrentsBottomPrioPostData = {
    /**
     * The hashes of the torrents you want to set to the minimum priority. `hashes` can contain multiple hashes separated by `|`, to set multiple torrents to the minimum priority, or set to `all`, to set all torrents to the minimum priority.
     */
    body: Hashes;
    path?: never;
    query?: never;
    url: '/torrents/bottomPrio';
};

export type TorrentsBottomPrioPostErrors = {
    /**
     * Torrent queueing is not enabled
     */
    409: unknown;
};

export type TorrentsBottomPrioPostResponses = {
    /**
     * All other scenarios
     */
    200: unknown;
};

export type TorrentsFilePrioPostData = {
    /**
     * `id` values correspond to file position inside the array returned by [torrent contents API](https://github.com/qbittorrent/qBittorrent/wiki/WebUI-API-(qBittorrent-4.1)#get-torrent-contents), e.g. `id=0` for first file, `id=1` for second file, etc.
     *
     * Since 2.8.2 it is reccomended to use `index` field returned by [torrent contents API](https://github.com/qbittorrent/qBittorrent/wiki/WebUI-API-(qBittorrent-4.1)#get-torrent-contents) (since the files can be filtered and the `index` value may differ from the position inside the response array).
     *
     */
    body: {
        /**
         * The hash of the torrent
         */
        hash: string;
        /**
         * File ids, separated by `|`
         */
        id: Array<number>;
        /**
         * File priority to set (consult [torrent contents API](https://github.com/qbittorrent/qBittorrent/wiki/WebUI-API-(qBittorrent-4.1)#get-torrent-contents) for possible values)
         */
        priority: 0 | 1 | 6 | 7;
    };
    path?: never;
    query?: never;
    url: '/torrents/filePrio';
};

export type TorrentsFilePrioPostErrors = {
    /**
     * Priority is invalid or At least one file `id` is not a valid integer
     */
    400: unknown;
    /**
     * Torrent hash was not found
     */
    404: unknown;
    /**
     * Torrent metadata hasn't downloaded yet or At least one file `id` was not found
     */
    409: unknown;
};

export type TorrentsFilePrioPostResponses = {
    /**
     * All other scenarios
     */
    200: unknown;
};

export type TorrentsDownloadLimitPostData = {
    /**
     * ```
     * POST /api/v2/torrents/downloadLimit HTTP/1.1
     * User-Agent: Fiddler
     * Host: 127.0.0.1
     * Cookie: SID=your_sid
     * Content-Type: application/x-www-form-urlencoded
     * Content-Length: length
     *
     * hashes=8c212779b4abde7c6bc608063a0d008b7e40ce32|284b83c9c7935002391129fd97f43db5d7cc2ba0
     * ```
     * `hashes` can contain multiple hashes separated by `|` or set to `all`
     *
     * Server reply (example):
     * ```
     * HTTP/1.1 200 OK
     * content-type: application/json
     * content-length: length
     *
     * {"8c212779b4abde7c6bc608063a0d008b7e40ce32":338944,"284b83c9c7935002391129fd97f43db5d7cc2ba0":123}
     * ```
     * `8c212779b4abde7c6bc608063a0d008b7e40ce32` is the hash of the torrent and `338944` its download speed limit in bytes per second; this value will be zero if no limit is applied.
     *
     */
    body: Hashes;
    path?: never;
    query?: never;
    url: '/torrents/downloadLimit';
};

export type TorrentsDownloadLimitPostResponses = {
    /**
     * All scenarios
     */
    200: TorrentsLimit;
};

export type TorrentsDownloadLimitPostResponse = TorrentsDownloadLimitPostResponses[keyof TorrentsDownloadLimitPostResponses];

export type TorrentsSetDownloadLimitPostData = {
    /**
     * ```
     * POST /api/v2/torrents/setDownloadLimit HTTP/1.1
     * User-Agent: Fiddler
     * Host: 127.0.0.1
     * Cookie: SID=your_sid
     * Content-Type: application/x-www-form-urlencoded
     * Content-Length: length
     *
     * hashes=8c212779b4abde7c6bc608063a0d008b7e40ce32|284b83c9c7935002391129fd97f43db5d7cc2ba0&limit=131072
     * ```
     * `hashes` can contain multiple hashes separated by `|` or set to `all` `limit` is the download speed limit in bytes per second you want to set.
     *
     */
    body: SetTorrentsLimit;
    path?: never;
    query?: never;
    url: '/torrents/setDownloadLimit';
};

export type TorrentsSetDownloadLimitPostResponses = {
    /**
     * All scenarios
     */
    200: unknown;
};

export type TorrentsSetShareLimitsPostData = {
    /**
     * ```
     * POST /api/v2/torrents/setShareLimits HTTP/1.1
     * User-Agent: Fiddler
     * Host: 127.0.0.1
     * Cookie: SID=your_sid
     * Content-Type: application/x-www-form-urlencoded
     * Content-Length: length
     *
     * hashes=8c212779b4abde7c6bc608063a0d008b7e40ce32|284b83c9c7935002391129fd97f43db5d7cc2ba0&ratioLimit=1.0&seedingTimeLimit=60
     * ```
     * `hashes` can contain multiple hashes separated by `|` or set to `all`
     *
     */
    body: Hashes & {
        /**
         * `ratioLimit` is the max ratio the torrent should be seeded until. `-2` means the global limit should be used, -1 means no limit.
         */
        ratioLimit: number;
        /**
         * `seedingTimeLimit` is the max amount of time the torrent should be seeded. `-2` means the global limit should be used, `-1` means no limit.
         */
        seedingTimeLimit: number;
    };
    path?: never;
    query?: never;
    url: '/torrents/setShareLimits';
};

export type TorrentsSetShareLimitsPostResponses = {
    /**
     * All scenarios
     */
    200: unknown;
};

export type TorrentsUploadLimitPostData = {
    /**
     * ```
     * POST /api/v2/torrents/uploadLimit HTTP/1.1
     * User-Agent: Fiddler
     * Host: 127.0.0.1
     * Cookie: SID=your_sid
     * Content-Type: application/x-www-form-urlencoded
     * Content-Length: length
     *
     * hashes=8c212779b4abde7c6bc608063a0d008b7e40ce32|284b83c9c7935002391129fd97f43db5d7cc2ba0
     * ```
     * `hashes` can contain multiple hashes separated by `|` or set to `all`
     *
     * Server reply (example):
     * ```
     * HTTP/1.1 200 OK
     * content-type: application/json
     * content-length: length
     *
     * {"8c212779b4abde7c6bc608063a0d008b7e40ce32":338944,"284b83c9c7935002391129fd97f43db5d7cc2ba0":123}
     * ```
     * `8c212779b4abde7c6bc608063a0d008b7e40ce32` is the hash of the torrent in the request and `338944` its upload speed limit in bytes per second; this value will be zero if no limit is applied.
     *
     */
    body: Hashes;
    path?: never;
    query?: never;
    url: '/torrents/uploadLimit';
};

export type TorrentsUploadLimitPostResponses = {
    /**
     * All scenarios
     */
    200: TorrentsLimit;
};

export type TorrentsUploadLimitPostResponse = TorrentsUploadLimitPostResponses[keyof TorrentsUploadLimitPostResponses];

export type TorrentsSetUploadLimitPostData = {
    /**
     * ```
     * POST /api/v2/torrents/setUploadLimit HTTP/1.1
     * User-Agent: Fiddler
     * Host: 127.0.0.1
     * Cookie: SID=your_sid
     * Content-Type: application/x-www-form-urlencoded
     * Content-Length: length
     *
     * hashes=8c212779b4abde7c6bc608063a0d008b7e40ce32|284b83c9c7935002391129fd97f43db5d7cc2ba0&limit=131072
     * ```
     * `hashes` can contain multiple hashes separated by `|` or set to `all` `limit` is the upload speed limit in bytes per second you want to set.
     *
     */
    body: SetTorrentsLimit;
    path?: never;
    query?: never;
    url: '/torrents/setUploadLimit';
};

export type TorrentsSetUploadLimitPostResponses = {
    /**
     * All scenarios
     */
    200: unknown;
};

export type TorrentsSetLocationPostData = {
    /**
     * ```
     * POST /api/v2/torrents/setLocation HTTP/1.1
     * User-Agent: Fiddler
     * Host: 127.0.0.1
     * Cookie: SID=your_sid
     * Content-Type: application/x-www-form-urlencoded
     * Content-Length: length
     *
     * hashes=8c212779b4abde7c6bc608063a0d008b7e40ce32|284b83c9c7935002391129fd97f43db5d7cc2ba0&location=/mnt/nfs/media
     * ```
     * `hashes` can contain multiple hashes separated by `|` or set to `all`
     *
     */
    body: Hashes & {
        /**
         * `location` is the location to download the torrent to. If the location doesn't exist, the torrent's location is unchanged.
         */
        location: string;
    };
    path?: never;
    query?: never;
    url: '/torrents/setLocation';
};

export type TorrentsSetLocationPostErrors = {
    /**
     * Save path is empty
     */
    400: unknown;
    /**
     * User does not have write access to directory
     */
    403: unknown;
    /**
     * Unable to create save path directory
     */
    409: unknown;
};

export type TorrentsSetLocationPostResponses = {
    /**
     * All other scenarios
     */
    200: unknown;
};

export type TorrentsRenamePostData = {
    /**
     * ```
     * POST /api/v2/torrents/rename HTTP/1.1
     * User-Agent: Fiddler
     * Host: 127.0.0.1
     * Cookie: SID=your_sid
     * Content-Type: application/x-www-form-urlencoded
     * Content-Length: length
     *
     * hash=8c212779b4abde7c6bc608063a0d008b7e40ce32&name=This%20is%20a%20test
     * ```
     *
     */
    body: {
        hash: string;
        name: string;
    };
    path?: never;
    query?: never;
    url: '/torrents/rename';
};

export type TorrentsRenamePostErrors = {
    /**
     * Torrent hash is invalid
     */
    404: unknown;
    /**
     * Torrent name is empty
     */
    409: unknown;
};

export type TorrentsRenamePostResponses = {
    /**
     * All other scenarios
     */
    200: unknown;
};

export type TorrentsSetCategoryPostData = {
    /**
     * ```
     * POST /api/v2/torrents/setCategory HTTP/1.1
     * User-Agent: Fiddler
     * Host: 127.0.0.1
     * Cookie: SID=your_sid
     * Content-Type: application/x-www-form-urlencoded
     * Content-Length: length
     *
     * hashes=8c212779b4abde7c6bc608063a0d008b7e40ce32|284b83c9c7935002391129fd97f43db5d7cc2ba0&category=CategoryName
     * ```
     * `hashes` can contain multiple hashes separated by `|` or set to `all`
     *
     */
    body: Hashes & {
        /**
         * `category` is the torrent category you want to set.
         */
        category: string;
    };
    path?: never;
    query?: never;
    url: '/torrents/setCategory';
};

export type TorrentsSetCategoryPostErrors = {
    /**
     * Category name does not exist
     */
    409: unknown;
};

export type TorrentsSetCategoryPostResponses = {
    /**
     * All other scenarios
     */
    200: unknown;
};

export type TorrentsCategoriesGetData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/torrents/categories';
};

export type TorrentsCategoriesGetResponses = {
    /**
     * All scenarios
     */
    200: {
        [key: string]: TorrentsCategory;
    };
};

export type TorrentsCategoriesGetResponse = TorrentsCategoriesGetResponses[keyof TorrentsCategoriesGetResponses];

export type TorrentsCreateCategoryPostData = {
    /**
     * ```
     * POST /api/v2/torrents/createCategory HTTP/1.1
     * User-Agent: Fiddler
     * Host: 127.0.0.1
     * Cookie: SID=your_sid
     * Content-Type: application/x-www-form-urlencoded
     * Content-Length: length
     *
     * category=CategoryName&savePath=/path/to/dir
     * ```
     * `category` is the category you want to create.
     *
     */
    body: Category;
    path?: never;
    query?: never;
    url: '/torrents/createCategory';
};

export type TorrentsCreateCategoryPostErrors = {
    /**
     * Category name is empty
     */
    400: unknown;
    /**
     * Category name is invalid
     */
    409: unknown;
};

export type TorrentsCreateCategoryPostResponses = {
    /**
     * All other scenarios
     */
    200: unknown;
};

export type TorrentsEditCategoryPostData = {
    /**
     * ```
     * POST /api/v2/torrents/editCategory HTTP/1.1
     * User-Agent: Fiddler
     * Host: 127.0.0.1
     * Cookie: SID=your_sid
     * Content-Type: application/x-www-form-urlencoded
     * Content-Length: length
     *
     * category=CategoryName&savePath=/path/to/save/torrents/to
     * ```
     *
     */
    body: Category;
    path?: never;
    query?: never;
    url: '/torrents/editCategory';
};

export type TorrentsEditCategoryPostErrors = {
    /**
     * Category name is empty
     */
    400: unknown;
    /**
     * Category editing failed
     */
    409: unknown;
};

export type TorrentsEditCategoryPostResponses = {
    /**
     * All other scenarios
     */
    200: unknown;
};

export type TorrentsRemoveCategoriesPostData = {
    /**
     * ```
     * POST /api/v2/torrents/removeCategories HTTP/1.1
     * User-Agent: Fiddler
     * Host: 127.0.0.1
     * Cookie: SID=your_sid
     * Content-Type: application/x-www-form-urlencoded
     * Content-Length: length
     *
     * categories=Category1%0ACategory2
     * ```
     *
     */
    body: {
        /**
         * `categories` can contain multiple cateogies separated by `\n` (%0A urlencoded)
         */
        categories: string;
    };
    path?: never;
    query?: never;
    url: '/torrents/removeCategories';
};

export type TorrentsRemoveCategoriesPostResponses = {
    /**
     * All scenarios
     */
    200: unknown;
};

export type TorrentsAddTagsPostData = {
    /**
     * ```
     * POST /api/v2/torrents/addTags HTTP/1.1
     * User-Agent: Fiddler
     * Host: 127.0.0.1
     * Cookie: SID=your_sid
     * Content-Type: application/x-www-form-urlencoded
     * Content-Length: length
     *
     * hashes=8c212779b4abde7c6bc608063a0d008b7e40ce32|284b83c9c7935002391129fd97f43db5d7cc2ba0&tags=TagName1,TagName2
     * ```
     * `hashes` can contain multiple hashes separated by `|` or set to `all`
     *
     * `tags` is the list of tags you want to add to passed torrents.
     *
     */
    body: TorrentsTags;
    path?: never;
    query?: never;
    url: '/torrents/addTags';
};

export type TorrentsAddTagsPostResponses = {
    /**
     * All scenarios
     */
    200: unknown;
};

export type TorrentsRemoveTagsPostData = {
    /**
     * ```
     * POST /api/v2/torrents/removeTags HTTP/1.1
     * User-Agent: Fiddler
     * Host: 127.0.0.1
     * Cookie: SID=your_sid
     * Content-Type: application/x-www-form-urlencoded
     * Content-Length: length
     *
     * hashes=8c212779b4abde7c6bc608063a0d008b7e40ce32|284b83c9c7935002391129fd97f43db5d7cc2ba0&tags=TagName1,TagName2
     * ```
     * `hashes` can contain multiple hashes separated by `|` or set to `all`
     *
     * `tags` is the list of tags you want to remove from passed torrents. Empty list removes all tags from relevant torrents.
     *
     */
    body: TorrentsTags;
    path?: never;
    query?: never;
    url: '/torrents/removeTags';
};

export type TorrentsRemoveTagsPostResponses = {
    /**
     * All scenarios
     */
    200: unknown;
};

export type TorrentsTagsGetData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/torrents/tags';
};

export type TorrentsTagsGetResponses = {
    /**
     * Returns all tags in JSON format, e.g.:
     */
    200: Array<string>;
};

export type TorrentsTagsGetResponse = TorrentsTagsGetResponses[keyof TorrentsTagsGetResponses];

export type TorrentsCreateTagsPostData = {
    /**
     * ```
     * POST /api/v2/torrents/createTags HTTP/1.1
     * User-Agent: Fiddler
     * Host: 127.0.0.1
     * Cookie: SID=your_sid
     * Content-Type: application/x-www-form-urlencoded
     * Content-Length: length
     *
     * tags=TagName1,TagName2
     * ```
     *
     */
    body: {
        /**
         * `tags` is a list of tags you want to create. Can contain multiple tags separated by `,`.
         */
        tags: Array<string>;
    };
    path?: never;
    query?: never;
    url: '/torrents/createTags';
};

export type TorrentsCreateTagsPostResponses = {
    /**
     * All scenarios
     */
    200: unknown;
};

export type TorrentsDeleteTagsPostData = {
    /**
     * ```
     * POST /api/v2/torrents/deleteTags HTTP/1.1
     * User-Agent: Fiddler
     * Host: 127.0.0.1
     * Cookie: SID=your_sid
     * Content-Type: application/x-www-form-urlencoded
     * Content-Length: length
     *
     * tags=TagName1,TagName2
     * ```
     *
     */
    body: {
        /**
         * `tags` is a list of tags you want to delete. Can contain multiple tags separated by `,`.
         */
        tags: Array<string>;
    };
    path?: never;
    query?: never;
    url: '/torrents/deleteTags';
};

export type TorrentsDeleteTagsPostResponses = {
    /**
     * All scenarios
     */
    200: unknown;
};

export type TorrentsSetAutoManagementPostData = {
    /**
     * ```
     * POST /api/v2/torrents/setAutoManagement HTTP/1.1
     * User-Agent: Fiddler
     * Host: 127.0.0.1
     * Cookie: SID=your_sid
     * Content-Type: application/x-www-form-urlencoded
     * Content-Length: length
     *
     * hashes=8c212779b4abde7c6bc608063a0d008b7e40ce32|284b83c9c7935002391129fd97f43db5d7cc2ba0&enable=true
     * ```
     * `hashes` can contain multiple hashes separated by `|` or set to `all`
     *
     */
    body: Hashes & {
        /**
         * `enable` is a boolean, affects the torrents listed in `hashes`, default is `false`
         */
        enable: boolean;
    };
    path?: never;
    query?: never;
    url: '/torrents/setAutoManagement';
};

export type TorrentsSetAutoManagementPostResponses = {
    /**
     * All scenarios
     */
    200: unknown;
};

export type TorrentsToggleSequentialDownloadPostData = {
    /**
     * The hashes of the torrents you want to toggle sequential download for. `hashes` can contain multiple hashes separated by `|`, to toggle sequential download for multiple torrents, or set to `all`, to toggle sequential download for all torrents.
     */
    body: Hashes;
    path?: never;
    query?: never;
    url: '/torrents/toggleSequentialDownload';
};

export type TorrentsToggleSequentialDownloadPostResponses = {
    /**
     * All scenarios
     */
    200: unknown;
};

export type TorrentsToggleFirstLastPiecePrioPostData = {
    /**
     * The hashes of the torrents you want to toggle the first/last piece priority for. `hashes` can contain multiple hashes separated by `|`, to toggle the first/last piece priority for multiple torrents, or set to `all`, to toggle the first/last piece priority for all torrents.
     */
    body: Hashes;
    path?: never;
    query?: never;
    url: '/torrents/toggleFirstLastPiecePrio';
};

export type TorrentsToggleFirstLastPiecePrioPostResponses = {
    /**
     * All scenarios
     */
    200: unknown;
};

export type TorrentsSetForceStartPostData = {
    /**
     * ```
     * POST /api/v2/torrents/setForceStart HTTP/1.1
     * User-Agent: Fiddler
     * Host: 127.0.0.1
     * Cookie: SID=your_sid
     * Content-Type: application/x-www-form-urlencoded
     * Content-Length: length
     *
     * hashes=8c212779b4abde7c6bc608063a0d008b7e40ce32?value=true
     * ```
     * `hashes` can contain multiple hashes separated by `|` or set to `all`
     *
     */
    body: SetTorrentsValue;
    path?: never;
    query?: never;
    url: '/torrents/setForceStart';
};

export type TorrentsSetForceStartPostResponses = {
    /**
     * All scenarios
     */
    200: unknown;
};

export type TorrentsSetSuperSeedingPostData = {
    /**
     * ```
     * POST /api/v2/torrents/setSuperSeeding HTTP/1.1
     * User-Agent: Fiddler
     * Host: 127.0.0.1
     * Cookie: SID=your_sid
     * Content-Type: application/x-www-form-urlencoded
     * Content-Length: length
     *
     * hashes=8c212779b4abde7c6bc608063a0d008b7e40ce32?value=true
     * ```
     * `hashes` can contain multiple hashes separated by `|` or set to `all`
     *
     */
    body: SetTorrentsValue;
    path?: never;
    query?: never;
    url: '/torrents/setSuperSeeding';
};

export type TorrentsSetSuperSeedingPostResponses = {
    /**
     * All scenarios
     */
    200: unknown;
};

export type TorrentsRenameFilePostData = {
    body: RenameTorrentFiles;
    path?: never;
    query?: never;
    url: '/torrents/renameFile';
};

export type TorrentsRenameFilePostErrors = {
    /**
     * Missing `newPath` parameter
     */
    400: unknown;
    /**
     * Invalid `newPath` or `oldPath`, or `newPath` already in use
     */
    409: unknown;
};

export type TorrentsRenameFilePostResponses = {
    /**
     * All other scenarios
     */
    200: unknown;
};

export type TorrentsRenameFolderPostData = {
    body: RenameTorrentFiles;
    path?: never;
    query?: never;
    url: '/torrents/renameFolder';
};

export type TorrentsRenameFolderPostErrors = {
    /**
     * Missing `newPath` parameter
     */
    400: unknown;
    /**
     * Invalid `newPath` or `oldPath`, or `newPath` already in use
     */
    409: unknown;
};

export type TorrentsRenameFolderPostResponses = {
    /**
     * All other scenarios
     */
    200: unknown;
};

export type RssAddFolderPostData = {
    body: {
        /**
         * Full path of added folder (e.g. "The Pirate Bay\Top100")
         */
        path: string;
    };
    path?: never;
    query?: never;
    url: '/rss/addFolder';
};

export type RssAddFolderPostErrors = {
    /**
     * Failure to add folder
     */
    409: unknown;
};

export type RssAddFolderPostResponses = {
    /**
     * All other scenarios
     */
    200: unknown;
};

export type RssAddFeedPostData = {
    body: {
        /**
         * URL of RSS feed (e.g. "http://thepiratebay.org/rss//top100/200")
         */
        url: string;
        /**
         * Full path of added folder (e.g. "The Pirate Bay\Top100\Video")
         */
        path?: string;
    };
    path?: never;
    query?: never;
    url: '/rss/addFeed';
};

export type RssAddFeedPostErrors = {
    /**
     * Failure to add feed
     */
    409: unknown;
};

export type RssAddFeedPostResponses = {
    /**
     * All other scenarios
     */
    200: unknown;
};

export type RssRemoveItemPostData = {
    body: {
        /**
         * Full path of removed item (e.g. "The Pirate Bay\Top100")
         */
        path: string;
    };
    path?: never;
    query?: never;
    url: '/rss/removeItem';
};

export type RssRemoveItemPostErrors = {
    /**
     * Failure to remove item
     */
    409: unknown;
};

export type RssRemoveItemPostResponses = {
    /**
     * All other scenarios
     */
    200: unknown;
};

export type RssMoveItemPostData = {
    body: {
        /**
         * Current full path of item (e.g. "The Pirate Bay\Top100")
         */
        itemPath: string;
        /**
         * New full path of item (e.g. "The Pirate Bay")
         */
        destPath: string;
    };
    path?: never;
    query?: never;
    url: '/rss/moveItem';
};

export type RssMoveItemPostErrors = {
    /**
     * Failure to move item
     */
    409: unknown;
};

export type RssMoveItemPostResponses = {
    /**
     * All other scenarios
     */
    200: unknown;
};

export type RssItemsPostData = {
    body: {
        /**
         * True if you need current feed articles
         */
        withData?: boolean;
    };
    path?: never;
    query?: never;
    url: '/rss/items';
};

export type RssItemsPostResponses = {
    /**
     * Returns all RSS items in JSON format, e.g.:
     */
    200: {
        [key: string]: unknown;
    };
};

export type RssItemsPostResponse = RssItemsPostResponses[keyof RssItemsPostResponses];

export type RssMarkAsReadPostData = {
    body: {
        /**
         * Current full path of item (e.g. "The Pirate Bay\Top100")
         */
        itemPath: string;
        /**
         * ID of article
         */
        articleId?: string;
    };
    path?: never;
    query?: never;
    url: '/rss/markAsRead';
};

export type RssMarkAsReadPostResponses = {
    /**
     * All scenarios
     */
    200: unknown;
};

export type RssRefreshItemPostData = {
    body: {
        /**
         * Current full path of item (e.g. "The Pirate Bay\Top100")
         */
        itemPath: string;
    };
    path?: never;
    query?: never;
    url: '/rss/refreshItem';
};

export type RssRefreshItemPostResponses = {
    /**
     * All scenarios
     */
    200: unknown;
};

export type RssSetRulePostData = {
    body: {
        /**
         * Rule name (e.g. "Punisher")
         */
        ruleName: string;
        ruleDef: RssRuleDef;
    };
    path?: never;
    query?: never;
    url: '/rss/setRule';
};

export type RssSetRulePostResponses = {
    /**
     * All scenarios
     */
    200: unknown;
};

export type RssRenameRulePostData = {
    body: {
        /**
         * Rule name (e.g. "Punisher")
         */
        ruleName: string;
        /**
         * New rule name (e.g. "The Punisher")
         */
        newRuleName: string;
    };
    path?: never;
    query?: never;
    url: '/rss/renameRule';
};

export type RssRenameRulePostResponses = {
    /**
     * All scenarios
     */
    200: unknown;
};

export type RssRemoveRulePostData = {
    body: {
        /**
         * Rule name (e.g. "Punisher")
         */
        ruleName: string;
    };
    path?: never;
    query?: never;
    url: '/rss/removeRule';
};

export type RssRemoveRulePostResponses = {
    /**
     * All scenarios
     */
    200: unknown;
};

export type RssRulesGetData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/rss/rules';
};

export type RssRulesGetResponses = {
    /**
     * Returns all auto-downloading rules in JSON format, e.g.:
     */
    200: {
        [key: string]: RssRuleDef;
    };
};

export type RssRulesGetResponse = RssRulesGetResponses[keyof RssRulesGetResponses];

export type RssMatchingArticlesPostData = {
    body: {
        /**
         * Rule name (e.g. "Linux")
         */
        ruleName: string;
    };
    path?: never;
    query?: never;
    url: '/rss/matchingArticles';
};

export type RssMatchingArticlesPostResponses = {
    /**
     * Returns all articles that match a rule by feed name in JSON format, e.g.:
     */
    200: {
        [key: string]: Array<string>;
    };
};

export type RssMatchingArticlesPostResponse = RssMatchingArticlesPostResponses[keyof RssMatchingArticlesPostResponses];

export type SearchStartPostData = {
    body: {
        /**
         * Pattern to search for (e.g. "Ubuntu 18.04")
         */
        pattern: string;
        /**
         * Plugins to use for searching (e.g. "legittorrents"). Supports multiple plugins separated by `|`. Also supports `all` and `enabled`
         */
        plugins: Array<string>;
        /**
         * Categories to limit your search to (e.g. "legittorrents"). Available categories depend on the specified `plugins`. Also supports `all`
         */
        category: Array<string>;
    };
    path?: never;
    query?: never;
    url: '/search/start';
};

export type SearchStartPostErrors = {
    /**
     * User has reached the limit of max `Running` searches (currently set to 5)
     */
    409: unknown;
};

export type SearchStartPostResponses = {
    /**
     * All other scenarios- see JSON below
     */
    200: SearchJob;
};

export type SearchStartPostResponse = SearchStartPostResponses[keyof SearchStartPostResponses];

export type SearchStopPostData = {
    body: SearchJob;
    path?: never;
    query?: never;
    url: '/search/stop';
};

export type SearchStopPostErrors = {
    /**
     * Search job was not found
     */
    404: unknown;
};

export type SearchStopPostResponses = {
    /**
     * All other scenarios
     */
    200: unknown;
};

export type SearchStatusPostData = {
    body: {
        /**
         * ID of the search job. If not specified, all search jobs are returned
         */
        id?: number;
    };
    path?: never;
    query?: never;
    url: '/search/status';
};

export type SearchStatusPostErrors = {
    /**
     * Search job was not found
     */
    404: unknown;
};

export type SearchStatusPostResponses = {
    /**
     * The response is a JSON array of objects containing the following fields
     */
    200: Array<SearchJobStatus>;
};

export type SearchStatusPostResponse = SearchStatusPostResponses[keyof SearchStatusPostResponses];

export type SearchResultsPostData = {
    body: SearchJob & {
        /**
         * max number of results to return. 0 or negative means no limit
         */
        limit?: number;
        /**
         * result to start at. A negative number means count backwards (e.g. -2 returns the 2 most recent results)
         */
        offset?: number;
    };
    path?: never;
    query?: never;
    url: '/search/results';
};

export type SearchResultsPostErrors = {
    /**
     * Search job was not found
     */
    404: unknown;
    /**
     * Offset is too large, or too small (e.g. absolute value of negative number is greater than # results)
     */
    409: unknown;
};

export type SearchResultsPostResponses = {
    /**
     * All other scenarios- see JSON below
     */
    200: SearchResults;
};

export type SearchResultsPostResponse = SearchResultsPostResponses[keyof SearchResultsPostResponses];

export type SearchDeletePostData = {
    body: {
        /**
         * ID of the search job
         */
        id: number;
    };
    path?: never;
    query?: never;
    url: '/search/delete';
};

export type SearchDeletePostErrors = {
    /**
     * Search job was not found
     */
    404: unknown;
};

export type SearchDeletePostResponses = {
    /**
     * All other scenarios
     */
    200: unknown;
};

export type SearchPluginsGetData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/search/plugins';
};

export type SearchPluginsGetResponses = {
    /**
     * The response is a JSON array of objects containing the following fields
     */
    200: Array<SearchPlugin>;
};

export type SearchPluginsGetResponse = SearchPluginsGetResponses[keyof SearchPluginsGetResponses];

export type SearchInstallPluginPostData = {
    body: {
        /**
         * Url or file path of the plugin to install (e.g. "https://raw.githubusercontent.com/qbittorrent/search-plugins/master/nova3/engines/legittorrents.py"). Supports multiple sources separated by `|`
         */
        sources: Array<string>;
    };
    path?: never;
    query?: never;
    url: '/search/installPlugin';
};

export type SearchInstallPluginPostResponses = {
    /**
     * All scenarios
     */
    200: unknown;
};

export type SearchUninstallPluginPostData = {
    body: {
        /**
         * Name of the plugin to uninstall (e.g. "legittorrents"). Supports multiple names separated by `|`
         */
        names: Array<string>;
    };
    path?: never;
    query?: never;
    url: '/search/uninstallPlugin';
};

export type SearchUninstallPluginPostResponses = {
    /**
     * All scenarios
     */
    200: unknown;
};

export type SearchEnablePluginPostData = {
    body: {
        /**
         * Name of the plugin to enable/disable (e.g. "legittorrents"). Supports multiple names separated by `|`
         */
        names: Array<string>;
        /**
         * Whether the plugins should be enabled
         */
        enable: boolean;
    };
    path?: never;
    query?: never;
    url: '/search/enablePlugin';
};

export type SearchEnablePluginPostResponses = {
    /**
     * All scenarios
     */
    200: unknown;
};

export type SearchUpdatePluginsPostData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/search/updatePlugins';
};

export type SearchUpdatePluginsPostResponses = {
    /**
     * All scenarios
     */
    200: unknown;
};

export type ClientOptions = {
    baseUrl: 'http://localhost:8080/api/v2' | (string & {});
};